#include <iostream>
#include <algorithm>

#include "ns3/core-module.h"
#include "ns3/mobility-module.h"
#include "ns3/leo-module.h"
#include "ns3/network-module.h"
#include "ns3/aodv-module.h"
#include "ns3/udp-server.h"

using namespace ns3;

// Satellite network setup
int port = 9;
NodeContainer satellites;
NodeContainer groundStations;
NetDeviceContainer utNet;
ApplicationContainer sinkApps;

std::map<std::pair<int, int>, bool> finished;
std::map<int, std::set<int>> satToGsMap;
std::set<int> gsStarted;
std::set<int> satFinished;

std::map<int, std::queue<std::pair<int, int>>> satTaskQueue;
std::set<int> satBusy;

static void EchoRx(std::string context, const Ptr< const Packet > packet, const TcpHeader &header, const Ptr< const TcpSocketBase > socket);
void SendPacket(int gsId, int satId);
string GetNodeId(string str);
void Connect();


static void EchoRx(std::string context, const Ptr< const Packet > packet, const TcpHeader &header, const Ptr< const TcpSocketBase > socket){
  // Task 3: Complete this function
  int nodeId = std::stoi(GetNodeId(context));
  int satId = nodeId;
  if ((uint32_t)satId >= satellites.GetN()) return;

  Ptr<PacketSink> sink = satellites.Get(satId)->GetApplication(0)->GetObject<PacketSink>();
  if (sink->GetTotalRx() >= 125000) {
    for (const auto &entry : finished) {
      int gsId = entry.first.first;
      int sid = entry.first.second;
      std::pair<int, int> key = std::make_pair(gsId, sid);
      
      if (sid == satId && !finished[key]) {
        finished[key] = true;
        
        std::ofstream log("recv_time.log", std::ios::app);
        log << "GS " << gsId << " -> SAT " << sid << " finishes at: " << Simulator::Now().GetSeconds() << "s\n";
        log.close();
      }
    }

    bool allDone = true;
    for (int gsId : satToGsMap[satId]) {
      std::pair<int, int> key = std::make_pair(gsId, satId);
      if (!finished[key]) {
        allDone = false;
        break;
      }
    }

    if (allDone && satFinished.find(satId) == satFinished.end()) {
      std::ofstream log("collection_time.log", std::ios::app);
      log << "SAT " << satId << " collects all data at: " << Simulator::Now().GetSeconds() << "s\n";
      log.close();
      satFinished.insert(satId);
    }
    
    if(!satTaskQueue[satId].empty()){
      auto [nextGsId, nextSatId] = satTaskQueue[satId].front();
      satTaskQueue[satId].pop();
      Simulator::ScheduleNow(&SendPacket, nextGsId, nextSatId);
    }else{
      satBusy.erase(satId);
    }

    for (const auto &entry : finished) {
      int gsId = entry.first.first;
      int sid = entry.first.second;
      if (gsStarted.count(gsId) == 0 && sid == satId) {
        gsStarted.insert(gsId);
        Simulator::Schedule(Simulator::Now(), &SendPacket, gsId, sid);
        break;
      }
    }
  }
}


void SendPacket(int gsId, int satId){
  // Task 2.1: Complete this function
  Ptr<Node> sender = groundStations.Get(gsId);           
  Ptr<Node> receiver = satellites.Get(satId);             

  Ipv4Address dstAddr = receiver->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal();  

  // TCP
  BulkSendHelper bulk("ns3::TcpSocketFactory", InetSocketAddress(dstAddr, port));
  bulk.SetAttribute("MaxBytes", UintegerValue(125000));  // 傳送上限：125000 bytes
  bulk.SetAttribute("SendSize", UintegerValue(512));     // 每次封包大小：512 bytes

  ApplicationContainer app = bulk.Install(sender);     
  Time now = Simulator::Now();  
  app.Start(now);
  app.Stop(Seconds(100.0));                              

  std::ofstream log("send_time.log", std::ios::app);
  log << "GS " << gsId << " -> SAT " << satId
      << " starts sending at: " << Simulator::Now().GetSeconds() << "s\n";
  log.close();
}



string GetNodeId(string str) {
  // Which node
  size_t pos1 = str.find("/", 0);           // The first "/"
  size_t pos2 = str.find("/", pos1 + 1);    // The second "/"
  size_t pos3 = str.find("/", pos2 + 1);    // The third "/"
  return str.substr(pos2 + 1, pos3 - pos2 - 1); // Node id
}

void Connect(){
  Config::Connect ("/NodeList/*/$ns3::TcpL4Protocol/SocketList/*/Rx", MakeCallback (&EchoRx));
}

NS_LOG_COMPONENT_DEFINE ("Lab4");

int main(int argc, char *argv[]){
	
  std::ofstream("send_time.log", std::ios::trunc).close();
  std::ofstream("recv_time.log", std::ios::trunc).close();
  std::ofstream("collection_time.log", std::ios::trunc).close();
  
  

  CommandLine cmd;
  string constellation = "TelesatGateway";
  double duration = 100;
  string inputFile = "network.ortools.out";
  string outputFile = "lab4.ortools.out";

  cmd.AddValue("duration", "Duration of the simulation in seconds", duration);
  cmd.AddValue("constellation", "LEO constellation link settings name", constellation);
  cmd.AddValue("inputFile", "Input file", inputFile);
  cmd.AddValue("outputFile", "Output file", outputFile);
  cmd.Parse (argc, argv);

  // Default setting
  Config::SetDefault("ns3::TcpSocket::SegmentSize", UintegerValue(512));
  Config::SetDefault("ns3::TcpSocketBase::MinRto", TimeValue(Seconds(2.0)));

  // Satellite
  LeoOrbitNodeHelper orbit;
  satellites = orbit.Install({ LeoOrbit(1200, 20, 1, 60)});

  // Ground station
  LeoGndNodeHelper ground;
  ground.Add(groundStations, LeoLatLong(20, 4));
  ground.Add(groundStations, LeoLatLong(19, 12));
  ground.Add(groundStations, LeoLatLong(19, 10));
  ground.Add(groundStations, LeoLatLong(19, 19));
  ground.Add(groundStations, LeoLatLong(19, 20));
  ground.Add(groundStations, LeoLatLong(18, 20));
  ground.Add(groundStations, LeoLatLong(18, 22));
  ground.Add(groundStations, LeoLatLong(17, 26));
  ground.Add(groundStations, LeoLatLong(18, 30));
  ground.Add(groundStations, LeoLatLong(15, 40));
  ground.Add(groundStations, LeoLatLong(14, 25));
  ground.Add(groundStations, LeoLatLong(14, 30));
  ground.Add(groundStations, LeoLatLong(14, 40));
  ground.Add(groundStations, LeoLatLong(14, 50));
  ground.Add(groundStations, LeoLatLong(14, 52));
  ground.Add(groundStations, LeoLatLong(13, 50));
  ground.Add(groundStations, LeoLatLong(13, 48));
  ground.Add(groundStations, LeoLatLong(12, 50));
  ground.Add(groundStations, LeoLatLong(13, 52));
  ground.Add(groundStations, LeoLatLong(15, 30));

  // Set network
  LeoChannelHelper utCh;
  utCh.SetConstellation (constellation);
  utNet = utCh.Install (satellites, groundStations);

  AodvHelper aodv;
  aodv.Set ("EnableHello", BooleanValue (false));
  
  InternetStackHelper stack;
  stack.SetRoutingHelper (aodv);
  stack.Install (satellites);
  stack.Install (groundStations);

  Ipv4AddressHelper ipv4;
  ipv4.SetBase ("10.1.0.0", "255.255.0.0");
  ipv4.Assign (utNet);

  // Receiver: satellites
  PacketSinkHelper sink("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address::GetAny(), port));
  for(int i=0; i<60; i++){
    sinkApps.Add(sink.Install(satellites.Get(i)));
  }

  // Task 1: Input File
  std::ifstream infile(inputFile);
  if (!infile.is_open()) {
    NS_LOG_ERROR("Cannot open input file: " << inputFile);
    return 1;
  }
  
  int src, dst;
  std::vector<std::pair<int, int>> sendTasks;
  std::string line;
  std::getline(infile, line); 
  
  while (infile >> src >> dst) {
    sendTasks.emplace_back(src, dst);
    finished[{src, dst}] = false;
    satToGsMap[dst].insert(src);
  }
  infile.close();


  // Task 2.2: Call SendPacket()
  for (auto [gsId, satId] : sendTasks) {
    satTaskQueue[satId].push({gsId, satId});
  }
  
  for (auto [satId, queue] : satTaskQueue) {
    if (!queue.empty()) {
      auto [gsId, sid] = queue.front();
      queue.pop();
      satBusy.insert(satId);
      Simulator::Schedule(Simulator::Now(), &SendPacket, gsId, sid);
    }
  }

  Simulator::Schedule(Seconds(1e-7), &Connect);
  Simulator::Stop (Seconds (duration));
  Simulator::Run ();
  Simulator::Destroy ();

  // Task 4: Output File
  // Task 4: Output File
  std::ofstream out(outputFile);
  if (!out.is_open()) {
    NS_LOG_ERROR("Cannot open output file: " << outputFile);
    return 1;
  }
  
  // 找出 total collection time（所有衛星的最大收集時間）
  double totalCollectionTime = 0.0;
  std::map<int, double> satCollectionTime;
  std::ifstream collectFile("collection_time.log");
  while (std::getline(collectFile, line)) {
    std::istringstream iss(line);
    std::string dummy;
    int satId;
    double time = 0.0;
    iss >> dummy >> satId >> dummy >> dummy >> dummy >> dummy >> time;
    satCollectionTime[satId] = time;
    totalCollectionTime = std::max(totalCollectionTime, time);
  }
  collectFile.close();
  
  // 解析 ground station 傳送與接收時間
  std::map<int, double> txStart, rxEnd;
  std::ifstream sendFile("send_time.log");
  while (std::getline(sendFile, line)) {
    std::istringstream iss(line);
    std::string dummy;
    int gsId;
    double time;
    iss >> dummy >> gsId >> dummy >> dummy >> dummy >> dummy >> dummy >> time;
    txStart[gsId] = time;
  }
  sendFile.close();
  
  std::ifstream recvFile("recv_time.log");
  while (std::getline(recvFile, line)) {
    std::istringstream iss(line);
    std::string dummy;
    int gsId;
    double time;
    iss >> dummy >> gsId >> dummy >> dummy >> dummy >> dummy >> dummy >> time;
    rxEnd[gsId] = time;
  }
  recvFile.close();
  
  // 輸出格式
  out << totalCollectionTime << "\n";
  out << "\n";
  // 衛星資訊（升冪排序）
  for(int satId = 0; satId < 10; ++satId){
    if (satCollectionTime.count(satId)){
      out << satId << " " << satCollectionTime[satId] << "\n";
    }
    else out << satId << " 0" << "\n";
  }
  //for (auto &[satId, time] : satCollectionTime) {
  //  out << satId << " " << time << "\n";
  //}
  out << "\n";
  // 地面站資訊（升冪排序）
  for (auto &[gsId, startTime] : txStart) {
    out << gsId << " " << startTime << " " << rxEnd[gsId] << "\n";
  }
  
  out.close();
  std::cout << "Output written to " << outputFile << std::endl;



  return 0;
}
