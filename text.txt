#include <bits/stdc++.h>
#include "ortools/linear_solver/linear_solver.h"

using namespace std;
using namespace operations_research;

const string STUDENT_ID = "111550005";

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int T;
  cin >> T;
  // 只印一次學號
  cout << STUDENT_ID << "\n";

  for (int tc = 0; tc < T; ++tc) {
    int N, E, F;
    cin >> N >> E >> F;
    vector<int> src(F), dst(F);
    for (int i = 0; i < F; ++i) {
      cin >> src[i] >> dst[i];
    }
    // 讀邊並存雙向有向圖
    map<pair<int,int>, double> capacity;
    vector<pair<int,int>> edges;
    edges.reserve(2 * E);
    for (int i = 0; i < E; ++i) {
      int u, v;
      double c;
      cin >> u >> v >> c;
      capacity[{u, v}] = c;
      capacity[{v, u}] = c;
      edges.emplace_back(u, v);
      edges.emplace_back(v, u);
    }
    int E2 = edges.size();

    // 建 MIP solver
    MPSolver solver("lab5", MPSolver::CBC_MIXED_INTEGER_PROGRAMMING);

    // 變數：x[f][e] (binary), y[e] (binary), flow[f] (continuous [0,1]), z[f][e] (continuous [0,1])
    vector<vector<MPVariable*>> x(F, vector<MPVariable*>(E2));
    vector<MPVariable*> y(E2);
    vector<MPVariable*> flow(F);
    vector<vector<MPVariable*>> z(F, vector<MPVariable*>(E2));

    for (int f = 0; f < F; ++f) {
      flow[f] = solver.MakeNumVar(0.0, 1.0, "flow_" + to_string(f));
      for (int e = 0; e < E2; ++e) {
        const auto& [u, v] = edges[e];
        x[f][e] = solver.MakeBoolVar(
            "x_" + to_string(f) + "_" + to_string(u) + "_" + to_string(v));
        z[f][e] = solver.MakeNumVar(0.0, 1.0,
            "z_" + to_string(f) + "_" + to_string(u) + "_" + to_string(v));
      }
    }
    for (int e = 0; e < E2; ++e) {
      const auto& [u, v] = edges[e];
      y[e] = solver.MakeBoolVar(
          "y_" + to_string(u) + "_" + to_string(v));
    }

    // 1. Y–Z binding: x[f][e] ≤ y[e]
    for (int f = 0; f < F; ++f) {
      for (int e = 0; e < E2; ++e) {
        MPConstraint* ct =
            solver.MakeRowConstraint(-MPSolver::infinity(), 0.0);
        ct->SetCoefficient(x[f][e],  1.0);
        ct->SetCoefficient(y[e],     -1.0);
      }
    }
    //    Σ_f x[f][e] ≥ y[e]
    for (int e = 0; e < E2; ++e) {
      MPConstraint* ct =
          solver.MakeRowConstraint(0.0, MPSolver::infinity());
      ct->SetCoefficient(y[e],  1.0);
      for (int f = 0; f < F; ++f) {
        ct->SetCoefficient(x[f][e], -1.0);
      }
    }

    // 2. 單一 transmitter per node: Σ_{e from u} y[e] ≤ 1
    for (int u = 0; u < N; ++u) {
      MPConstraint* ct =
          solver.MakeRowConstraint(-MPSolver::infinity(), 1.0);
      for (int e = 0; e < E2; ++e) {
        if (edges[e].first == u) {
          ct->SetCoefficient(y[e], 1.0);
        }
      }
    }
    // 3. 單一 receiver per node: Σ_{e to v} y[e] ≤ 1
    for (int v = 0; v < N; ++v) {
      MPConstraint* ct =
          solver.MakeRowConstraint(-MPSolver::infinity(), 1.0);
      for (int e = 0; e < E2; ++e) {
        if (edges[e].second == v) {
          ct->SetCoefficient(y[e], 1.0);
        }
      }
    }

    // 4. Flow conservation & single-path
    for (int f = 0; f < F; ++f) {
      // 中繼點 k: Σ_in x = Σ_out x
      for (int k = 0; k < N; ++k) {
        if (k == src[f] || k == dst[f]) continue;
        MPConstraint* ct = solver.MakeRowConstraint(0.0, 0.0);
        for (int e = 0; e < E2; ++e) {
          const auto& [u, v] = edges[e];
          if (v == k) ct->SetCoefficient(x[f][e],  1.0);
          if (u == k) ct->SetCoefficient(x[f][e], -1.0);
        }
      }
      // 源點：Σ_out x − Σ_in x = flow[f]
      {
        MPConstraint* ct = solver.MakeRowConstraint(0.0, 0.0);
        for (int e = 0; e < E2; ++e) {
          const auto& [u, v] = edges[e];
          if (u == src[f]) ct->SetCoefficient(x[f][e],  1.0);
          if (v == src[f]) ct->SetCoefficient(x[f][e], -1.0);
        }
        ct->SetCoefficient(flow[f], -1.0);
      }
      // 匯點：Σ_in x − Σ_out x = flow[f]
      {
        MPConstraint* ct = solver.MakeRowConstraint(0.0, 0.0);
        for (int e = 0; e < E2; ++e) {
          const auto& [u, v] = edges[e];
          if (v == dst[f]) ct->SetCoefficient(x[f][e],  1.0);
          if (u == dst[f]) ct->SetCoefficient(x[f][e], -1.0);
        }
        ct->SetCoefficient(flow[f], -1.0);
      }
    }

    // 5. 線性化 z[f][e] = x[f][e] * flow[f] （M=1）
    for (int f = 0; f < F; ++f) {
      for (int e = 0; e < E2; ++e) {
        // z ≤ x
        {
          MPConstraint* ct =
            solver.MakeRowConstraint(-MPSolver::infinity(), 0.0);
          ct->SetCoefficient(z[f][e], 1.0);
          ct->SetCoefficient(x[f][e], -1.0);
        }
        // z ≤ flow
        {
          MPConstraint* ct =
            solver.MakeRowConstraint(-MPSolver::infinity(), 0.0);
          ct->SetCoefficient(z[f][e],     1.0);
          ct->SetCoefficient(flow[f],     -1.0);
        }
        // z + x ≥ flow  ↔  z ≥ flow − (1−x)
        {
          MPConstraint* ct =
            solver.MakeRowConstraint(0.0, MPSolver::infinity());
          ct->SetCoefficient(z[f][e], 1.0);
          ct->SetCoefficient(x[f][e], 1.0);
          ct->SetCoefficient(flow[f], -1.0);
        }
      }
    }

    // 6. 容量限制：Σ_f z[f][e] ≤ capacity[e]
    for (int e = 0; e < E2; ++e) {
      const auto& edge = edges[e];
      double cap = capacity[edge];
      MPConstraint* ct =
        solver.MakeRowConstraint(-MPSolver::infinity(), cap);
      for (int f = 0; f < F; ++f) {
        ct->SetCoefficient(z[f][e], 1.0);
      }
    }

    // 目標：最大化 Σ_f flow[f]
    MPObjective* objective = solver.MutableObjective();
    for (int f = 0; f < F; ++f) {
      objective->SetCoefficient(flow[f], 1.0);
    }
    objective->SetMaximization();

    // Solve
    const MPSolver::ResultStatus status = solver.Solve();
    if (status != MPSolver::OPTIMAL) {
      cerr << "Testcase " << tc << ": No optimal solution\n";
    }

    // 輸出每條 SD pair 的 flow（0 or 1）
    cout << fixed << setprecision(6);
    for (int f = 0; f < F; ++f) {
      double val = flow[f]->solution_value();
      cout << val << (f + 1 < F ? " " : "\n");
    }
  }

  return 0;
}
