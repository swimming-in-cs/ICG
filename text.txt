//  ╔════════════════════════════════════════════════════════════════════╗
//  ║  Lab 5 – OR‑Tools CP‑SAT exact solver (max‑throughput single‑path) ║
//  ║  –––  generated by ChatGPT, 2025‑05‑20                           ║
//  ║                                                                  ║
//  ║  Compile (example):                                              ║
//  ║    g++ -std=c++17 -O2 -I/path/to/ortools/include \
//  ║        lab5_ortools.cc -L/path/to/ortools/lib -lortools -lglog   ║
//  ║                                                                  ║
//  ║  **Important**:  Replace STUDENT_ID with your real ID before     ║
//  ║  submitting to the judge.                                        ║
//  ╚════════════════════════════════════════════════════════════════════╝

#include <bits/stdc++.h>
#include "ortools/sat/cp_model.h"

using namespace std;
using namespace operations_research;
using namespace operations_research::sat;

// ──────────────────────────────────────────────────────────────────────
// Parameters & types
// ──────────────────────────────────────────────────────────────────────
static constexpr long long SCALE = 1'000'000; // 6‑digit fixed‑point ⇢ 1e‑6 precision
static const string STUDENT_ID   = "YOUR_STUDENT_ID"; // ←←  ！！改成你的學號！！

struct DirEdge {
    int from, to;            // 0‑based node indices
    long long cap;           // integer capacity (= real * SCALE)
};

// ──────────────────────────────────────────────────────────────────────
// Helper to rebuild a path from selected x‑variables (one outgoing per node)
// ──────────────────────────────────────────────────────────────────────
static vector<int> ReconstructPath(int n, int src, int dst,
                                   const vector<vector<int>>& out_edges_of_node,
                                   const vector<DirEdge>& edges,
                                   const vector<IntVar>& x_vars,
                                   const CpSolverResponse& resp) {
    vector<int> path; path.reserve(n);
    if (src == dst) { path.push_back(src); return path; }

    unordered_set<int> visited;
    int cur = src; path.push_back(cur);
    while (cur != dst) {
        bool found = false;
        for (int eid : out_edges_of_node[cur]) {
            if (SolutionIntegerValue(resp, x_vars[eid])) {
                int nxt = edges[eid].to;
                path.push_back(nxt);
                cur = nxt;
                found = true;
                break;
            }
        }
        if (!found || visited.count(cur)) { // failsafe: loop or dead‑end
            path.clear();
            break;
        }
        visited.insert(cur);
    }
    return path;
}

// ──────────────────────────────────────────────────────────────────────
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T; if (!(cin >> T)) return 0;
    cout << STUDENT_ID << '\n';

    long double total_throughput_all_tests = 0.0L;

    for (int tc = 0; tc < T; ++tc) {
        int N, E, F; cin >> N >> E >> F;

        // ── build undirected edges list ──
        struct UEdge { int u,v; long double cap; };
        vector<UEdge> undirected(E);
        long double max_cap_real = 0.0L;
        for (int i = 0;i < E;++i) {
            int u,v; long double r; cin >> u >> v >> r;
            --u; --v; // convert to 0‑based
            undirected[i] = {u,v,r};
            max_cap_real = max(max_cap_real, r);
        }

        // ── SD pairs ──
        vector<pair<int,int>> sd(F);
        for (int k = 0;k < F;++k) {
            int s,d; cin >> s >> d; --s; --d;
            sd[k] = {s,d};
        }

        // ── construct directed edge list ──
        vector<DirEdge> dir_edges; dir_edges.reserve(2*E);
        vector<vector<int>> out_edges_of_node(N), in_edges_of_node(N);
        for (const auto& e : undirected) {
            long long cap_int = static_cast<long long>(llround(e.cap * SCALE));
            int id_fwd = (int)dir_edges.size();
            dir_edges.push_back({e.u, e.v, cap_int});
            out_edges_of_node[e.u].push_back(id_fwd);
            in_edges_of_node [e.v].push_back(id_fwd);

            int id_rev = (int)dir_edges.size();
            dir_edges.push_back({e.v, e.u, cap_int});
            out_edges_of_node[e.v].push_back(id_rev);
            in_edges_of_node [e.u].push_back(id_rev);
        }
        const int M = (int)dir_edges.size();
        const long long R_MAX_INT = static_cast<long long>(llround(max_cap_real * SCALE));

        // ──────────────────────────────────────────────────────────────
        //  CP‑SAT model
        // ──────────────────────────────────────────────────────────────
        CpModelBuilder model;

        // y[e]
        vector<IntVar> y_vars(M);
        for (int e = 0;e < M;++e) {
            y_vars[e] = model.NewBoolVar();
        }

        // x[k][e], f[k][e], R[k]
        vector<vector<IntVar>> x_vars(F, vector<IntVar>(M));
        vector<vector<IntVar>> f_vars(F, vector<IntVar>(M));
        vector<IntVar> R_vars(F);

        for (int k = 0;k < F;++k) {
            R_vars[k] = model.NewIntVar(Domain(0, R_MAX_INT));
            for (int e = 0;e < M;++e) {
                x_vars[k][e] = model.NewBoolVar();
                f_vars[k][e] = model.NewIntVar(Domain(0, dir_edges[e].cap));
                // f <= cap * x
                model.AddLessOrEqual(f_vars[k][e], dir_edges[e].cap * LinearExpr(x_vars[k][e]));
                // x <= y
                model.AddLessOrEqual(x_vars[k][e], y_vars[e]);
            }
        }

        // (1) Capacity per directed edge: Σ_k f_k,e ≤ cap_e
        for (int e = 0;e < M;++e) {
            LinearExpr total_on_e;
            for (int k = 0;k < F;++k) total_on_e += f_vars[k][e];
            model.AddLessOrEqual(total_on_e, dir_edges[e].cap);
        }

        // (2) Flow conservation per SD pair
        for (int k = 0;k < F;++k) {
            int src = sd[k].first;
            int dst = sd[k].second;
            for (int v = 0; v < N; ++v) {
                LinearExpr out_expr, in_expr;
                for (int eid : out_edges_of_node[v]) out_expr += f_vars[k][eid];
                for (int eid :  in_edges_of_node[v]) in_expr  += f_vars[k][eid];
                if (v == src) {
                    model.AddEquality(out_expr - in_expr, R_vars[k]);
                } else if (v == dst) {
                    model.AddEquality(out_expr - in_expr, LinearExpr(-1) * R_vars[k]);
                } else {
                    model.AddEquality(out_expr - in_expr, 0);
                }
            }
        }

        // (3) Transmitter / receiver limit per node: ≤ 1 outgoing / incoming y
        for (int v = 0; v < N; ++v) {
            LinearExpr sum_out;
            for (int eid : out_edges_of_node[v]) sum_out += y_vars[eid];
            model.AddLessOrEqual(sum_out, 1);
            LinearExpr sum_in;
            for (int eid : in_edges_of_node[v]) sum_in += y_vars[eid];
            model.AddLessOrEqual(sum_in, 1);
        }

        // (Optional) – maximize Σ R_k
        LinearExpr objective;
        for (int k = 0;k < F;++k) objective += R_vars[k];
        model.Maximize(objective);

        // ── Solve ──
        Model m;
        // speed‑up parameters (optional)
        SatParameters params;
        params.set_num_search_workers(max(1, (int)std::thread::hardware_concurrency()));
        params.set_max_time_in_seconds(0.95); // adhere to 1‑second TL per test in statement
        m.Add(NewSatParameters(params));

        CpSolverResponse resp = SolveCpModel(model.Build(), &m);

        // ──────────────────────────────────────────────────────────────
        //  Output (as per spec) – scaling back to real numbers
        // ──────────────────────────────────────────────────────────────
        vector<pair<int,int>> used_links; used_links.reserve(M);
        for (int e = 0;e < M;++e) {
            if (SolutionIntegerValue(resp, y_vars[e])) {
                used_links.push_back({dir_edges[e].from, dir_edges[e].to});
            }
        }
        cout << used_links.size() << '\n';
        for (auto [u,v] : used_links) {
            cout << (u+1) << ' ' << (v+1) << '\n'; // back to 1‑based
        }

        // Per‑pair output & accumulate throughput
        long double throughput_this_test = 0.0L;
        cout.setf(ios::fixed); cout << setprecision(6);
        for (int k = 0;k < F;++k) {
            long long R_int = SolutionIntegerValue(resp, R_vars[k]);
            if (resp.status() != CpSolverStatus::OPTIMAL &&
                resp.status() != CpSolverStatus::FEASIBLE) R_int = 0;
            if (R_int == 0) {
                cout << "0 0\n";
                continue;
            }
            // rebuild path
            vector<int> path = ReconstructPath(N, sd[k].first, sd[k].second,
                                               out_edges_of_node, dir_edges,
                                               x_vars[k], resp);
            if (path.empty()) {
                // should not happen, but guard
                cout << "0 0\n";
                continue;
            }
            long double R_real = (long double)R_int / SCALE;
            throughput_this_test += R_real;

            cout << R_real << ' ' << (int)path.size();
            for (int v : path) cout << ' ' << (v+1);
            cout << '\n';
        }

        cout << throughput_this_test << '\n';
        total_throughput_all_tests += throughput_this_test;
    }

    cout.setf(ios::fixed); cout << setprecision(6);
    cout << (long double)(total_throughput_all_tests / T) << '\n';
    return 0;
}
