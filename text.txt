#include <bits/stdc++.h>
#include "ortools/linear_solver/linear_solver.h"
using namespace std;
using namespace operations_research;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int t;
  cin >> t;
  double total_throughput_all = 0.0;

  for (int tc = 0; tc < t; ++tc) {
    int n, m, F;
    cin >> n >> m >> F;
    vector<tuple<int,int,double>> undirected_edges(m);
    for (int i = 0; i < m; ++i) {
      cin >> get<0>(undirected_edges[i]) >> get<1>(undirected_edges[i]) >> get<2>(undirected_edges[i]);
    }
    vector<pair<int,int>> sd(F);
    for (int k = 0; k < F; ++k) cin >> sd[k].first >> sd[k].second;

    // Build directed edges
    vector<pair<int,int>> edges;
    vector<double> capacity;
    edges.reserve(2*m);
    capacity.reserve(2*m);
    for (auto &e : undirected_edges) {
      int u, v; double cap;
      tie(u, v, cap) = e;
      edges.emplace_back(u, v);
      capacity.push_back(cap);
      edges.emplace_back(v, u);
      capacity.push_back(cap);
    }
    int E = edges.size();

    // Determine large M for linearization
    double M = 0;
    for (double c : capacity) M = max(M, c);

    // Create solver
    unique_ptr<MPSolver> solver(MPSolver::CreateSolver("CBC_MIXED_INTEGER_PROGRAMMING"));
    if (!solver) return 1;

    // Variables
    vector<vector<const MPVariable*>> x(F, vector<const MPVariable*>(E));
    for (int k = 0; k < F; ++k) {
      for (int e = 0; e < E; ++e) {
        x[k][e] = solver->MakeBoolVar("x_" + to_string(k) + "_" + to_string(e));
      }
    }
    vector<const MPVariable*> z(E);
    for (int e = 0; e < E; ++e) {
      z[e] = solver->MakeBoolVar("z_" + to_string(e));
    }
    vector<const MPVariable*> f(F);
    for (int k = 0; k < F; ++k) {
      f[k] = solver->MakeNumVar(0.0, M, "f_" + to_string(k));
    }
    vector<vector<const MPVariable*>> y(F, vector<const MPVariable*>(E));
    for (int k = 0; k < F; ++k) {
      for (int e = 0; e < E; ++e) {
        y[k][e] = solver->MakeNumVar(0.0, M, "y_" + to_string(k) + "_" + to_string(e));
      }
    }

    // Constraints
    const double INF = solver->infinity();
    // 1) x[k][e] <= z[e]
    for (int k = 0; k < F; ++k) {
      for (int e = 0; e < E; ++e) {
        MPConstraint* ct = solver->MakeRowConstraint(-INF, 0.0);
        ct->SetCoefficient(x[k][e], 1);
        ct->SetCoefficient(z[e], -1);
      }
    }
    // 2) z[e] <= sum_k x[k][e]
    for (int e = 0; e < E; ++e) {
      MPConstraint* ct = solver->MakeRowConstraint(-INF, 0.0);
      ct->SetCoefficient(z[e], 1);
      for (int k = 0; k < F; ++k) {
        ct->SetCoefficient(x[k][e], -1);
      }
    }
    // 3) single transmitter: sum_{out(v)} z <= 1
    for (int v = 1; v <= n; ++v) {
      MPConstraint* ct = solver->MakeRowConstraint(-INF, 1.0);
      for (int e = 0; e < E; ++e) if (edges[e].first == v) ct->SetCoefficient(z[e], 1);
    }
    // 4) single receiver: sum_{in(v)} z <= 1
    for (int v = 1; v <= n; ++v) {
      MPConstraint* ct = solver->MakeRowConstraint(-INF, 1.0);
      for (int e = 0; e < E; ++e) if (edges[e].second == v) ct->SetCoefficient(z[e], 1);
    }
    // 5) flow conservation and single path
    for (int k = 0; k < F; ++k) {
      int src = sd[k].first, dst = sd[k].second;
      for (int v = 1; v <= n; ++v) {
        double lb = 0.0, ub = 0.0;
        if (v == src) { lb = 1.0; ub = 1.0; }
        else if (v == dst) { lb = -1.0; ub = -1.0; }
        else { lb = 0.0; ub = 0.0; }
        // Note: for src, out-in == 1 => out - in >=1 and <=1; for dst in-out ==1 => out - in <= -1 and >= -1
        MPConstraint* ct = solver->MakeRowConstraint(lb, ub);
        for (int e = 0; e < E; ++e) {
          if (edges[e].first == v) ct->SetCoefficient(x[k][e], 1);
          if (edges[e].second == v) ct->SetCoefficient(x[k][e], -1);
        }
      }
    }
    // 6) capacity: y[k][e] <= f[k]; y[k][e] <= M*x[k][e]
    for (int k = 0; k < F; ++k) {
      for (int e = 0; e < E; ++e) {
        // y - f <= 0
        MPConstraint* c1 = solver->MakeRowConstraint(-INF, 0.0);
        c1->SetCoefficient(y[k][e], 1);
        c1->SetCoefficient(f[k], -1);
        // y - M*x <= 0
        MPConstraint* c2 = solver->MakeRowConstraint(-INF, 0.0);
        c2->SetCoefficient(y[k][e], 1);
        c2->SetCoefficient(x[k][e], -M);
      }
    }
    // 7) sum_k y[k][e] <= capacity[e]
    for (int e = 0; e < E; ++e) {
      MPConstraint* ct = solver->MakeRowConstraint(-INF, capacity[e]);
      for (int k = 0; k < F; ++k) ct->SetCoefficient(y[k][e], 1);
    }

    // Objective: maximize sum f[k]
    MPObjective* obj = solver->MutableObjective();
    for (int k = 0; k < F; ++k) obj->SetCoefficient(f[k], 1);
    obj->SetMaximization();

    // Solve
    auto result_status = solver->Solve();
    if (result_status != MPSolver::OPTIMAL) {
      cerr << "No optimal solution found\n";
      return 1;
    }

    // Recover paths and output
    vector<pair<int,int>> used_links;
    for (int e = 0; e < E; ++e) {
      if (z[e]->solution_value() > 0.5) used_links.push_back(edges[e]);
    }
    cout << used_links.size() << '\n';
    for (auto &uv : used_links) cout << uv.first << ' ' << uv.second << '\n';
    double sum_th = 0;
    for (int k = 0; k < F; ++k) {
      double fk = f[k]->solution_value();
      sum_th += fk;
      if (fk < 1e-9) {
        cout << "0 0\n";
      } else {
        // reconstruct path
        vector<int> path;
        int cur = sd[k].first;
        path.push_back(cur);
        while (cur != sd[k].second) {
          for (int e = 0; e < E; ++e) {
            if (edges[e].first == cur && x[k][e]->solution_value() > 0.5) {
              cur = edges[e].second;
              path.push_back(cur);
              break;
            }
          }
        }
        cout << fk << ' ' << path.size();
        for (int v : path) cout << ' ' << v;
        cout << '\n';
      }
    }
    cout << sum_th << '\n';
    total_throughput_all += sum_th;
  }
  // average throughput
  cout << (total_throughput_all / t) << '\n';
  return 0;
}
