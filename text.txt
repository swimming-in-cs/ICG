#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <algorithm>
#include <climits>
#include <queue>
#include <ortools/linear_solver/linear_solver.h>

using namespace std;
using namespace operations_research;

// Structure to represent an edge in the network
struct Edge {
    int src, dst;
    int capacity;
    Edge(int s, int d, int c) : src(s), dst(d), capacity(c) {}
};

// Structure to represent a source-destination (SD) pair
struct SDPair {
    int src, dst;
    SDPair(int s, int d) : src(s), dst(d) {}
};

int main() {
    // Step 1: Parse input
    int n, m, k;
    cin >> n >> m >> k;
    
    // Read edges (links)
    vector<Edge> edges;
    map<pair<int, int>, int> edge_index;
    map<pair<int, int>, int> edge_capacity;
    
    for (int i = 0; i < m; i++) {
        int src, dst, capacity;
        cin >> src >> dst >> capacity;
        edges.push_back(Edge(src, dst, capacity));
        edge_index[{src, dst}] = i;
        edge_capacity[{src, dst}] = capacity;
    }
    
    // Read source-destination pairs
    vector<SDPair> sd_pairs;
    for (int i = 0; i < k; i++) {
        int src, dst;
        cin >> src >> dst;
        sd_pairs.push_back(SDPair(src, dst));
    }
    
    // Step 2: Set up the solver
    unique_ptr<MPSolver> solver(MPSolver::CreateSolver("SCIP"));
    if (!solver) {
        cerr << "SCIP solver not available." << endl;
        return 1;
    }
    
    // Define decision variables
    
    // y[i][e]: whether SD pair i uses edge e
    vector<vector<MPVariable*>> y(k);
    for (int i = 0; i < k; i++) {
        y[i].resize(m);
        for (int e = 0; e < m; e++) {
            y[i][e] = solver->MakeIntVar(0, 1, "y_" + to_string(i) + "_" + to_string(e));
        }
    }
    
    // z[e]: whether edge e is used by any SD pair
    vector<MPVariable*> z(m);
    for (int e = 0; e < m; e++) {
        z[e] = solver->MakeIntVar(0, 1, "z_" + to_string(e));
    }
    
    // x[i]: traffic amount for SD pair i
    vector<MPVariable*> x(k);
    for (int i = 0; i < k; i++) {
        x[i] = solver->MakeNumVar(0, solver->infinity(), "x_" + to_string(i));
    }
    
    // Step 3: Add constraints
    
    // Flow conservation constraint
    for (int i = 0; i < k; i++) {
        for (int node = 0; node < n; node++) {
            MPConstraint* flow_constraint = solver->MakeRowConstraint(0, 0);
            
            // Source node: outgoing - incoming = 1
            if (node == sd_pairs[i].src) {
                flow_constraint->SetBounds(1, 1);
            }
            // Destination node: outgoing - incoming = -1
            else if (node == sd_pairs[i].dst) {
                flow_constraint->SetBounds(-1, -1);
            }
            // Intermediate node: outgoing - incoming = 0
            
            // Add outgoing edges
            for (int e = 0; e < m; e++) {
                if (edges[e].src == node) {
                    flow_constraint->SetCoefficient(y[i][e], 1);
                }
            }
            
            // Subtract incoming edges
            for (int e = 0; e < m; e++) {
                if (edges[e].dst == node) {
                    flow_constraint->SetCoefficient(y[i][e], -1);
                }
            }
        }
    }
    
    // Link capacity constraint
    for (int e = 0; e < m; e++) {
        MPConstraint* capacity_constraint = solver->MakeRowConstraint(0, edges[e].capacity);
        for (int i = 0; i < k; i++) {
            capacity_constraint->SetCoefficient(x[i], y[i][e]);
        }
    }
    
    // Task 1: Add the following three constraints:
    
    // 1. Y-Z binding constraint: z[e] = 1 if edge e is used by any SD pair
    for (int e = 0; e < m; e++) {
        for (int i = 0; i < k; i++) {
            // If y[i][e] = 1, then z[e] must be at least 1
            MPConstraint* binding_constraint = solver->MakeRowConstraint(-solver->infinity(), 0);
            binding_constraint->SetCoefficient(y[i][e], 1);
            binding_constraint->SetCoefficient(z[e], -1);
        }
        
        // Sum of y[i][e] across all i should be <= k * z[e]
        MPConstraint* sum_constraint = solver->MakeRowConstraint(-solver->infinity(), 0);
        for (int i = 0; i < k; i++) {
            sum_constraint->SetCoefficient(y[i][e], 1);
        }
        sum_constraint->SetCoefficient(z[e], -k);
    }
    
    // 2. Single transmitter per node constraint
    for (int node = 0; node < n; node++) {
        MPConstraint* out_constraint = solver->MakeRowConstraint(0, 1);
        for (int e = 0; e < m; e++) {
            if (edges[e].src == node) {
                out_constraint->SetCoefficient(z[e], 1);
            }
        }
    }
    
    // 3. Single receiver per node constraint
    for (int node = 0; node < n; node++) {
        MPConstraint* in_constraint = solver->MakeRowConstraint(0, 1);
        for (int e = 0; e < m; e++) {
            if (edges[e].dst == node) {
                in_constraint->SetCoefficient(z[e], 1);
            }
        }
    }
    
    // Step 4: Set objective function
    MPObjective* objective = solver->MutableObjective();
    for (int i = 0; i < k; i++) {
        objective->SetCoefficient(x[i], 1);
    }
    objective->SetMaximization();
    
    // Step 5: Solve
    const MPSolver::ResultStatus result_status = solver->Solve();
    
    // Step 6: Print results
    if (result_status == MPSolver::OPTIMAL || result_status == MPSolver::FEASIBLE) {
        cout << k << endl;
        
        for (int i = 0; i < k; i++) {
            // Get the traffic amount for this SD pair
            double traffic = x[i]->solution_value();
            
            // Collect edges used in the path
            vector<int> path_edges;
            for (int e = 0; e < m; e++) {
                if (y[i][e]->solution_value() > 0.5) {
                    path_edges.push_back(e);
                }
            }
            
            // Count the number of nodes in the path
            set<int> path_nodes;
            path_nodes.insert(sd_pairs[i].src);
            path_nodes.insert(sd_pairs[i].dst);
            for (int e : path_edges) {
                path_nodes.insert(edges[e].src);
                path_nodes.insert(edges[e].dst);
            }
            
            // Output SD pair information
            cout << sd_pairs[i].src << " " << sd_pairs[i].dst << " " << traffic << " " << path_nodes.size() << " ";
            
            // Reconstruct the path
            int current = sd_pairs[i].src;
            cout << current << " ";
            
            while (current != sd_pairs[i].dst) {
                for (int e : path_edges) {
                    if (edges[e].src == current) {
                        current = edges[e].dst;
                        cout << current << " ";
                        break;
                    }
                }
            }
            cout << endl;
        }
    } else {
        cout << "No solution found." << endl;
    }
    
    return 0;
}
