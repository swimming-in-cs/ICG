#include "ortools/linear_solver/linear_solver.h"
#include <iostream>
#include <vector>
#include <string>
#include <iomanip>
#include <algorithm>

using namespace operations_research;

int main() {
  const std::string student_id = "YOUR_STUDENT_ID";
  int t;
  if (!(std::cin >> t)) return 0;
  std::cout << student_id << std::endl;

  double sum_throughput = 0.0;

  for (int tc = 0; tc < t; ++tc) {
    int N, E, F;
    std::cin >> N >> E >> F;

    struct Edge { int u, v; double cap; };
    std::vector<Edge> dir_edges;
    dir_edges.reserve(E * 2);
    for (int i = 0; i < E; ++i) {
      int u, v;
      double cap;
      std::cin >> u >> v >> cap;
      dir_edges.push_back({u, v, cap});
      dir_edges.push_back({v, u, cap});
    }
    int M = dir_edges.size();

    std::vector<int> src(F), dst(F);
    for (int k = 0; k < F; ++k) std::cin >> src[k] >> dst[k];

    // Determine Big-M for each SD pair: use max capacity across all edges
    double max_cap = 0.0;
    for (auto &e : dir_edges) max_cap = std::max(max_cap, e.cap);

    MPSolver solver("lab5_mip_tc_" + std::to_string(tc),
                     MPSolver::CBC_MIXED_INTEGER_PROGRAMMING);

    // Variables
    std::vector<std::vector<const MPVariable*>> x(F, std::vector<const MPVariable*>(M));
    for (int k = 0; k < F; ++k) {
      for (int e = 0; e < M; ++e) {
        x[k][e] = solver.MakeBoolVar("x_" + std::to_string(k) + "_" + std::to_string(e));
      }
    }
    std::vector<const MPVariable*> y(M);
    for (int e = 0; e < M; ++e) {
      y[e] = solver.MakeBoolVar("y_" + std::to_string(e));
    }
    std::vector<const MPVariable*> f(F);
    for (int k = 0; k < F; ++k) {
      f[k] = solver.MakeNumVar(0.0, solver.infinity(), "f_" + std::to_string(k));
    }

    // Flow conservation constraints
    for (int k = 0; k < F; ++k) {
      for (int i = 0; i < N; ++i) {
        double rhs = (i == src[k]) ? 1.0 : (i == dst[k]) ? -1.0 : 0.0;
        MPConstraint* ct = solver.MakeRowConstraint(rhs, rhs);
        for (int e = 0; e < M; ++e) {
          if (dir_edges[e].u == i) ct->SetCoefficient(x[k][e], 1);
          if (dir_edges[e].v == i) ct->SetCoefficient(x[k][e], -1);
        }
      }
    }

    // Binding: x <= y for each k,e
    for (int k = 0; k < F; ++k) {
      for (int e = 0; e < M; ++e) {
        MPConstraint* ct = solver.MakeRowConstraint(-solver.infinity(), 0.0);
        ct->SetCoefficient(x[k][e], 1);
        ct->SetCoefficient(y[e], -1);
      }
    }

    // Capacity constraints
    // (1) If x[k][e] = 0 then f[k] <= 0; enforce f[k] <= M * x[k][e]
    for (int k = 0; k < F; ++k) {
      for (int e = 0; e < M; ++e) {
        MPConstraint* ct = solver.MakeRowConstraint(-solver.infinity(), 0.0);
        ct->SetCoefficient(f[k], 1);
        ct->SetCoefficient(x[k][e], -max_cap);
      }
    }
    // (2) Sum_k f[k] <= cap[e] * y[e]
    for (int e = 0; e < M; ++e) {
      MPConstraint* ct = solver.MakeRowConstraint(-solver.infinity(), dir_edges[e].cap);
      for (int k = 0; k < F; ++k) {
        ct->SetCoefficient(f[k], 1);
      }
      ct->SetCoefficient(y[e], -dir_edges[e].cap);
    }

    // Objective: maximize total throughput
    MPObjective* obj = solver.MutableObjective();
    for (int k = 0; k < F; ++k) obj->SetCoefficient(f[k], 1);
    obj->SetMaximization();

    // Solve
    const MPSolver::ResultStatus status = solver.Solve();
    if (status != MPSolver::OPTIMAL) {
      std::cerr << "No optimal solution for test case " << tc + 1 << std::endl;
      continue;
    }

    // Output used directed links
    std::vector<std::pair<int,int>> used;
    for (int e = 0; e < M; ++e) {
      if (y[e]->solution_value() > 0.5) {
        used.emplace_back(dir_edges[e].u, dir_edges[e].v);
      }
    }
    std::cout << used.size() << std::endl;
    for (auto &p : used) {
      std::cout << p.first << " " << p.second << std::endl;
    }

    // Output SD pair solutions
    double total_th = 0.0;
    std::cout << std::fixed << std::setprecision(6);
    for (int k = 0; k < F; ++k) {
      double rate = f[k]->solution_value();
      if (rate < 1e-9) {
        std::cout << "0 0" << std::endl;
      } else {
        total_th += rate;
        std::vector<int> path;
        int cur = src[k]; path.push_back(cur);
        while (cur != dst[k]) {
          for (int e = 0; e < M; ++e) {
            if (dir_edges[e].u == cur && x[k][e]->solution_value() > 0.5) {
              cur = dir_edges[e].v;
              path.push_back(cur);
              break;
            }
          }
        }
        std::cout << rate << " " << path.size();
        for (int v : path) std::cout << " " << v;
        std::cout << std::endl;
      }
    }

    std::cout << total_th << std::endl;
    sum_throughput += total_th;
  }

  double avg = sum_throughput / t;
  std::cout << std::fixed << std::setprecision(6) << avg << std::endl;
  return 0;
}
