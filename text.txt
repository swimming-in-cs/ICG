#include <bits/stdc++.h>
#include "ortools/linear_solver/linear_solver.h"
#include "absl/time/time.h"
using namespace std;
using namespace operations_research;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // Print student ID
  cout << "111550005\n";

  int T; cin >> T;
  vector<double> throughputs(T);

  for (int tc = 0; tc < T; ++tc) {
    int U, E, F;
    cin >> U >> E >> F;
    int N = U;

    // Read edges
    vector<pair<int,int>> edges;
    vector<double> cap;
    vector<vector<int>> adj(N);
    edges.reserve(2*E);
    cap.reserve(2*E);
    for (int i = 0; i < E; ++i) {
      int u,v; double r;
      cin >> u >> v >> r;
      edges.emplace_back(u,v); cap.push_back(r); adj[u].push_back(edges.size()-1);
      edges.emplace_back(v,u); cap.push_back(r); adj[v].push_back(edges.size()-1);
    }
    vector<int> src(F), dst(F);
    for (int i = 0; i < F; ++i) cin >> src[i] >> dst[i];

    // Solver
    unique_ptr<MPSolver> solver(MPSolver::CreateSolver("CBC_MIXED_INTEGER_PROGRAMMING"));
    if (!solver) return 1;
    const double INF = solver->infinity();

    // Variables
    vector<MPVariable*> f(F);
    vector<MPVariable*> y(F);
    for (int i = 0; i < F; ++i) {
      f[i] = solver->MakeNumVar(0.0, INF, "f"+to_string(i));
      y[i] = solver->MakeBoolVar("y"+to_string(i));
    }
    vector<vector<MPVariable*>> x(F, vector<MPVariable*>(edges.size()));
    for (int i = 0; i < F; ++i)
      for (int e = 0; e < (int)edges.size(); ++e)
        x[i][e] = solver->MakeBoolVar("x_"+to_string(i)+"_"+to_string(e));

    // Objective
    MPObjective* obj = solver->MutableObjective();
    for (int i = 0; i < F; ++i) obj->SetCoefficient(f[i], 1);
    obj->SetMaximization();

    double max_r = *max_element(cap.begin(), cap.end());
    // Constraints
    for (int i = 0; i < F; ++i) {
      // f[i] <= max_r * y[i]
      solver->MakeRowConstraint(f[i] <= max_r * y[i]);
      for (int e = 0; e < (int)edges.size(); ++e) {
        // f[i] <= cap[e] * x[i][e]
        solver->MakeRowConstraint(f[i] <= cap[e] * x[i][e]);
      }
      for (int u = 0; u < N; ++u) {
        double b = (u==src[i] ? 1 : (u==dst[i] ? -1 : 0));
        // sum_out - sum_in = b*y[i]
        MPConstraint* ct = solver->MakeRowConstraint(b*y[i], b*y[i]);
        for (int eid: adj[u]) ct->SetCoefficient(x[i][eid], 1);
        for (int e = 0; e < (int)edges.size(); ++e)
          if (edges[e].second==u) ct->SetCoefficient(x[i][e], -1);
      }
    }
    // Node degree
    for (int u = 0; u < N; ++u) {
      MPConstraint* cout = solver->MakeRowConstraint(0, 1);
      MPConstraint* cin = solver->MakeRowConstraint(0, 1);
      for (int i = 0; i < F; ++i) {
        for (int eid: adj[u]) cout->SetCoefficient(x[i][eid], 1);
        for (int e = 0; e < (int)edges.size(); ++e)
          if (edges[e].second==u) cin->SetCoefficient(x[i][e], 1);
      }
    }
    solver->SetTimeLimit(absl::Milliseconds(10000));
    auto status = solver->Solve();
    if (status!=MPSOLVER_OPTIMAL && status!=MPSOLVER_FEASIBLE) return 1;

    // Extract
    set<pair<int,int>> used;
    vector<double> flow_val(F);
    for (int i = 0; i < F; ++i) {
      flow_val[i] = f[i]->solution_value();
      if (flow_val[i]<=1e-9) continue;
      for (int e = 0; e < (int)edges.size(); ++e)
        if (x[i][e]->solution_value()>0.5)
          used.insert(edges[e]);
    }
    cout<<used.size()<<"\n";
    for(auto&p:used) cout<<p.first<<" "<<p.second<<"\n";

    cout<<fixed<<setprecision(6);
    double sum=0;
    for (int i=0;i<F;++i) {
      if (flow_val[i]<=1e-9) { cout<<"0 0\n"; continue; }
      // rebuild
      vector<int> prev(N,-1), path;
      queue<int>q;
      prev[src[i]]=src[i]; q.push(src[i]);
      while(!q.empty()){
        int u=q.front();q.pop(); if(u==dst[i])break;
        for(int eid:adj[u]){
          auto [a,b]=edges[eid];
          if(a==u && used.count({a,b}) && prev[b]==-1){ prev[b]=u; q.push(b);} }
      }
      int cur=dst[i]; while(cur!=prev[cur]){ path.push_back(cur); cur=prev[cur]; }
      path.push_back(cur); reverse(path.begin(),path.end());
      cout<<flow_val[i]<<" "<<path.size(); for(int v:path) cout<<" "<<v; cout<<"\n";
      sum+=flow_val[i];
    }
    cout<<sum<<"\n";
    throughputs[tc]=sum;
  }
  double avg=accumulate(throughputs.begin(),throughputs.end(),0.0)/T;
  cout<<fixed<<setprecision(6)<<avg<<"\n";
  return 0;
}
