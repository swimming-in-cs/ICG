#include <bits/stdc++.h>
#include "ortools/linear_solver/linear_solver.h"
#include "absl/time/time.h"
using namespace std;
using namespace operations_research;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  // Print student ID
  string student_id = "111550005";
  cout << student_id << "\n";

  int T;
  cin >> T;
  vector<double> throughputs(T);

  for (int tc = 0; tc < T; ++tc) {
    int U, E, F;
    cin >> U >> E >> F;
    int N = U;

    // Read edges and capacities
    vector<pair<int,int>> edges;
    vector<double> cap;
    vector<vector<int>> adj(N);
    edges.reserve(2*E);
    cap.reserve(2*E);
    for (int i = 0; i < E; ++i) {
      int u, v;
      double r;
      cin >> u >> v >> r;
      // directed copies
      edges.emplace_back(u, v);
      cap.push_back(r);
      adj[u].push_back(edges.size()-1);
      edges.emplace_back(v, u);
      cap.push_back(r);
      adj[v].push_back(edges.size()-1);
    }

    vector<int> src(F), dst(F);
    for (int i = 0; i < F; ++i) cin >> src[i] >> dst[i];

    // Create MIP solver (CBC)
    std::unique_ptr<MPSolver> solver(
      MPSolver::CreateSolver("CBC_MIXED_INTEGER_PROGRAMMING"));
    if (!solver) {
      cerr << "Solver not available." << endl;
      return 1;
    }
    const double INF = solver->infinity();

    // Variables: flow amounts f[i]
    vector<MPVariable*> f(F);
    for (int i = 0; i < F; ++i) {
      f[i] = solver->MakeNumVar(0.0, INF, "f_" + to_string(i));
    }
    // Variables: x[i][e]
    vector<vector<MPVariable*>> x(F, vector<MPVariable*>(edges.size()));
    for (int i = 0; i < F; ++i) {
      for (int e = 0; e < (int)edges.size(); ++e) {
        x[i][e] = solver->MakeBoolVar("x_" + to_string(i) + "_" + to_string(e));
      }
    }

    // Objective: maximize sum of flows
    MPObjective* obj = solver->MutableObjective();
    for (int i = 0; i < F; ++i) obj->SetCoefficient(f[i], 1);
    obj->SetMaximization();

    // 1) Capacity: f[i] <= cap[e] * x[i][e]
    for (int i = 0; i < F; ++i) {
      for (int e = 0; e < (int)edges.size(); ++e) {
        MPConstraint* ct = solver->MakeRowConstraint(-INF, 0.0);
        ct->SetCoefficient(f[i], 1);
        ct->SetCoefficient(x[i][e], -cap[e]);
      }
    }

    // 2) Flow conservation at each node
    for (int i = 0; i < F; ++i) {
      for (int u = 0; u < N; ++u) {
        double bound = (u == src[i] ? 1.0 : (u == dst[i] ? -1.0 : 0.0));
        MPConstraint* ct = solver->MakeRowConstraint(bound, bound);
        // outgoing edges
        for (int eid : adj[u]) ct->SetCoefficient(x[i][eid], 1);
        // incoming edges
        for (int e = 0; e < (int)edges.size(); ++e) {
          if (edges[e].second == u) ct->SetCoefficient(x[i][e], -1);
        }
      }
    }

    // 3) Node degree: at most one outgoing and one incoming total
    for (int u = 0; u < N; ++u) {
      MPConstraint* cout = solver->MakeRowConstraint(0.0, 1.0);
      MPConstraint* cin_ = solver->MakeRowConstraint(0.0, 1.0);
      for (int i = 0; i < F; ++i) {
        for (int eid : adj[u]) cout->SetCoefficient(x[i][eid], 1);
        for (int e = 0; e < (int)edges.size(); ++e) {
          if (edges[e].second == u) cin_->SetCoefficient(x[i][e], 1);
        }
      }
    }

    // Time limit: 10 seconds
    solver->SetTimeLimit(absl::Milliseconds(10000));

    // Solve
    const MPSolver::ResultStatus status = solver->Solve();
    if (status != MPSolver::OPTIMAL && status != MPSolver::FEASIBLE) {
      cerr << "No solution" << endl;
      return 1;
    }

    // Extract solution
    set<pair<int,int>> used_dir;
    vector<double> flow_val(F, 0.0);
    for (int i = 0; i < F; ++i) {
      flow_val[i] = f[i]->solution_value();
      if (flow_val[i] < 1e-9) continue;
      for (int e = 0; e < (int)edges.size(); ++e) {
        if (x[i][e]->solution_value() > 0.5) used_dir.insert(edges[e]);
      }
    }

    // Reconstruct and output
    cout << used_dir.size() << "\n";
    for (auto &pr : used_dir) cout << pr.first << " " << pr.second << "\n";

    cout << fixed << setprecision(6);
    double sum_tp = 0;
    for (int i = 0; i < F; ++i) {
      if (flow_val[i] > 1e-9) {
        // BFS to rebuild path
        vector<int> prev(N, -1);
        queue<int> q;
        prev[src[i]] = src[i];
        q.push(src[i]);
        while (!q.empty()) {
          int u = q.front(); q.pop();
          if (u == dst[i]) break;
          for (int eid : adj[u]) {
            auto [a, b] = edges[eid];
            if (a == u && used_dir.count({a,b}) && prev[b] == -1) {
              prev[b] = u;
              q.push(b);
            }
          }
        }
        vector<int> path;
        int cur = dst[i];
        while (cur != prev[cur]) {
          path.push_back(cur);
          cur = prev[cur];
        }
        path.push_back(cur);
        reverse(path.begin(), path.end());
        cout << flow_val[i] << " " << path.size();
        for (int v : path) cout << " " << v;
        cout << "\n";
        sum_tp += flow_val[i];
      } else {
        cout << "0 0\n";
      }
    }
    cout << sum_tp << "\n";
    throughputs[tc] = sum_tp;
  }

  double avg = accumulate(throughputs.begin(), throughputs.end(), 0.0) / T;
  cout << fixed << setprecision(6) << avg << "\n";
  return 0;
}
