#include "ortools/linear_solver/linear_solver.h"
#include <iostream>
#include <vector>
#include <string>
#include <iomanip>
#include <algorithm>

using namespace operations_research;

int main() {
  const std::string student_id = "YOUR_STUDENT_ID";
  int t;
  if (!(std::cin >> t)) return 0;
  std::cout << student_id << std::endl;

  double sum_throughput = 0.0;

  for (int tc = 0; tc < t; ++tc) {
    int N, E, F;
    std::cin >> N >> E >> F;

    struct Edge { int u, v; double cap; };
    std::vector<Edge> dir_edges;
    dir_edges.reserve(E * 2);
    for (int i = 0; i < E; ++i) {
      int u, v;
      double cap;
      std::cin >> u >> v >> cap;
      dir_edges.push_back({u, v, cap});
      dir_edges.push_back({v, u, cap});
    }
    int M = dir_edges.size();

    std::vector<int> src(F), dst(F);
    for (int k = 0; k < F; ++k) std::cin >> src[k] >> dst[k];

    // Compute Big-M
    double max_cap = 0;
    for (auto &e : dir_edges) max_cap = std::max(max_cap, e.cap);

    MPSolver solver("lab5_linearized_tc_" + std::to_string(tc),
                     MPSolver::CBC_MIXED_INTEGER_PROGRAMMING);

    // Decision variables
    // x[k][e]: binary, path uses edge e for SD pair k
    std::vector<std::vector<const MPVariable*>> x(F, std::vector<const MPVariable*>(M));
    for (int k = 0; k < F; ++k)
      for (int e = 0; e < M; ++e)
        x[k][e] = solver.MakeBoolVar("x_" + std::to_string(k) + "_" + std::to_string(e));

    // y[e]: binary, if edge e is constructed
    std::vector<const MPVariable*> y(M);
    for (int e = 0; e < M; ++e)
      y[e] = solver.MakeBoolVar("y_" + std::to_string(e));

    // f[k]: continuous throughput for SD pair k
    std::vector<const MPVariable*> f(F);
    for (int k = 0; k < F; ++k)
      f[k] = solver.MakeNumVar(0.0, solver.infinity(), "f_" + std::to_string(k));

    // f_ke[k][e]: continuous flow of pair k on edge e
    std::vector<std::vector<const MPVariable*>> f_ke(
        F, std::vector<const MPVariable*>(M));
    for (int k = 0; k < F; ++k)
      for (int e = 0; e < M; ++e)
        f_ke[k][e] = solver.MakeNumVar(0.0, solver.infinity(),
                                       "fke_" + std::to_string(k) + "_" + std::to_string(e));

    // 1) Flow conservation on x for each SD pair
    for (int k = 0; k < F; ++k) {
      for (int i = 0; i < N; ++i) {
        double rhs = (i == src[k] ? 1.0 : (i == dst[k] ? -1.0 : 0.0));
        MPConstraint* ct = solver.MakeRowConstraint(rhs, rhs);
        for (int e = 0; e < M; ++e) {
          if (dir_edges[e].u == i) ct->SetCoefficient(x[k][e], 1);
          if (dir_edges[e].v == i) ct->SetCoefficient(x[k][e], -1);
        }
      }
    }

    // 2) Link activation: x[k][e] <= y[e]
    for (int k = 0; k < F; ++k)
      for (int e = 0; e < M; ++e)
        solver.MakeRowConstraint(-solver.infinity(), 0.0)
            ->SetCoefficient(x[k][e], 1)
            ->SetCoefficient(y[e], -1);

    // 3) Linearize f_ke = f_k * x_k_e
    //    f_ke <= r_e * x_ke
    for (int k = 0; k < F; ++k)
      for (int e = 0; e < M; ++e)
        solver.MakeRowConstraint(-solver.infinity(), dir_edges[e].cap)
            ->SetCoefficient(f_ke[k][e], 1)
            ->SetCoefficient(x[k][e], -dir_edges[e].cap);
    //    f_ke <= f[k]
    for (int k = 0; k < F; ++k)
      for (int e = 0; e < M; ++e)
        solver.MakeRowConstraint(-solver.infinity(), 0.0)
            ->SetCoefficient(f_ke[k][e], 1)
            ->SetCoefficient(f[k], -1);
    //    f_ke >= f[k] - M*(1-x)
    for (int k = 0; k < F; ++k)
      for (int e = 0; e < M; ++e)
        solver.MakeRowConstraint(-max_cap, solver.infinity())
            ->SetCoefficient(f_ke[k][e], 1)
            ->SetCoefficient(f[k], -1)
            ->SetCoefficient(x[k][e], max_cap);

    // 4) Edge capacity: sum_k f_ke[k][e] <= r_e
    for (int e = 0; e < M; ++e) {
      MPConstraint* ct = solver.MakeRowConstraint(-solver.infinity(), dir_edges[e].cap);
      for (int k = 0; k < F; ++k) ct->SetCoefficient(f_ke[k][e], 1);
    }

    // 5) Throughput definition: f[k] <= sum_e f_ke[k][e]
    // Actually, maximize f[k], so this ties f[k] to its used edges.
    for (int k = 0; k < F; ++k) {
      MPConstraint* ct = solver.MakeRowConstraint(0.0, solver.infinity());
      ct->SetCoefficient(f[k], 1);
      for (int e = 0; e < M; ++e) ct->SetCoefficient(f_ke[k][e], -1);
    }

    // Objective: maximize sum_k f[k]
    MPObjective* obj = solver.MutableObjective();
    for (int k = 0; k < F; ++k) obj->SetCoefficient(f[k], 1);
    obj->SetMaximization();

    const auto status = solver.Solve();
    if (status != MPSolver::OPTIMAL) {
      std::cerr << "No optimal solution for test case " << tc+1 << std::endl;
      continue;
    }

    // Output constructed directed links
    std::vector<std::pair<int,int>> used;
    for (int e = 0; e < M; ++e) {
      if (y[e]->solution_value() > 0.5) used.emplace_back(dir_edges[e].u, dir_edges[e].v);
    }
    std::cout << used.size() << std::endl;
    for (auto &p : used) std::cout << p.first << " " << p.second << std::endl;

    // Output SD pair rates and paths
    double total_tc = 0;
    std::cout << std::fixed << std::setprecision(6);
    for (int k = 0; k < F; ++k) {
      double rate = f[k]->solution_value();
      if (rate < 1e-9) {
        std::cout << "0 0" << std::endl;
      } else {
        total_tc += rate;
        // Reconstruct path via x[k][e]
        std::vector<int> path;
        int cur = src[k]; path.push_back(cur);
        while (cur != dst[k]) {
          for (int e = 0; e < M; ++e) {
            if (dir_edges[e].u==cur && x[k][e]->solution_value()>0.5) {
              cur = dir_edges[e].v;
              path.push_back(cur);
              break;
            }
          }
        }
        std::cout << rate << " " << path.size();
        for (int v : path) std::cout << " " << v;
        std::cout << std::endl;
      }
    }
    std::cout << total_tc << std::endl;
    sum_throughput += total_tc;
  }

  double avg = sum_throughput / t;
  std::cout << std::fixed << std::setprecision(6) << avg << std::endl;
  return 0;
}
